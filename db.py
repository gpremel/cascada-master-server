"""Defines the object used to communicate with the SQL server"""

import mysql.connector

import json
import logging
import math
from numbers import Number
from typing import Dict, Type, Tuple

import vartypes


class BDDException(Exception):
    pass


class BDDExceptionTableNonValidee(BDDException):
    """The supplied name for the project matches an existing table that is not compatible with
    the supplied scheme for the project"""


class BDDExceptionVariableNonValide(BDDException):
    """At least one of the names choosed for the variables has been rejected by the
    database server.
    Please choose another one"""


class BDDExceptionResultatsIngerable(BDDException):
    """Query result could not be interpreted by the program"""


class controlleurBDD():
    def __init__(self, nom_projet: str,
                 schema: Dict[str, Type[vartypes.csc_var]], fichier_login: str):
        """Initializes the database driver

        Params:
            nom_projet: the name given to the project, used to create/open a table
            schema: the data scheme used. For instance, for two outgoing variables:
                                - K: float
                                - n: uint32
                            that are going to be generated by the server, sent to the client
                            which will compute a new variable:
                                - E: float
                            the scheme is {"K": csc_float, "n": csc_uint32, "E": csc_float}
            fichier_login: the name of the file used to connect to the database server
        """

        self.nom_projet = nom_projet
        self.schema = schema

        if "id" in schema or "niv_densification" in schema:
            raise BDDExceptionVariableNonValide

        with open(fichier_login, "r") as f:
            self.creds = json.load(f)

        logging.info("Connexion à la BDD \"{}\" avec l'utilisateur {}@{}".format(
            self.creds["db"], self.creds["user"], self.creds["host"]))

        self.cnx = mysql.connector.connect(
            host=self.creds["host"],
            port=self.creds["port"],
            user=self.creds["user"],
            password=self.creds["pass"],
            database=self.creds["db"]
        )

        self.seuil_densification = None
        self.variable_densification = None
        self.offset_cour_densification = 0
        self.limite_select = None

        self.densifie = False

        self.a_afficher_erreur_plus_echantillon = False

        # the densification depth
        # we have no choice but to save it in the table; if we don't, each time we'll reach a
        # new densification level, we run the risk of "drowning" the best candidates of the
        # old level with new records
        self.niveau_densification = 1

        cursor = self.cnx.cursor()

        # First off, we check whether a table with the same project name exists
        r = cursor.execute("""SELECT COUNT(*)
                                FROM information_schema.tables
                                WHERE table_name = %s AND table_schema = %s
                                LIMIT 1""", (nom_projet, self.creds["db"]))

        nb_tables = cursor.fetchone()[0]

        schema_sql = [nom + " " + str(vartype.to_SQL_type()) for nom, vartype in schema.items()]
        schema_sql.append("niv_densification INT UNSIGNED ")
        schema_sql.append("id INT NOT NULL AUTO_INCREMENT, PRIMARY KEY (id)")

        if nb_tables != 0:
            logging.info("Table {} already exists !".format(nom_projet))

            # Check that the table is compatible
            cursor.execute("DESCRIBE {};".format(nom_projet))
            for r in cursor:
                # Name...
                if r[0] in schema:
                    # Type...
                    if str(r[1]).casefold() != str(schema[r[0]].to_SQL_type()).casefold():
                        raise BDDExceptionTableNonValidee
                elif r[0] == "niv_densification":
                    if str(r[1]).casefold() != str(vartypes.csc_uint32.to_SQL_type()).casefold():
                        raise BDDExceptionTableNonValidee

            logging.info("Table validated")
        else:       # simpler case: table doesn't exist
            # Sadly, we have no choice but to use string substitution.
            # However, that's not really such a big deal here; we're not reading user input, but
            # extracting data from the running Python code.
            # I guess that if a third-party is able to hijack Python code running on the server, we
            # have a much bigger issue that a "simple" SQLi
            cursor.execute("CREATE TABLE {} ({});".format(nom_projet, ", ".join(schema_sql)))
            logging.info("La table {} n'existait pas, on vient de la créer !".format(nom_projet))
        cursor.close()

    def enregistrer(self, resultat: Dict[str, vartypes.csc_var]):
        """Saves the result of a computation in the database

        Params:
            resultat: the result of the computation, with the following shape:
                                {"variable name": variable_value}
                        variable_value being an instance of the cascada type matching the
                        type assigned to said variable in the scheme provided during the
                        initialization

                        Example:
                            {"K": csc_float(7.4), "n": csc_uint32(14638), "E": csc_float(15.9)}

        Returns:
            None
        """

        cursor = self.cnx.cursor()
        # Recasting
        r2 = {}
        for nom, type_var in self.schema.items():
            r2[nom] = type_var(resultat[nom])
        resultat = r2
        resultat["niv_densification"] = vartypes.csc_int32(self.niveau_densification)
        cursor.execute("""INSERT INTO {} ({}) VALUES ({})""".format(self.nom_projet,
                                                                    ", ".join(resultat.keys()),
                                                                    ", ".join(
                                                                        [r'%s' for x
                                                                         in resultat.keys()])),
                       tuple([str(x) for x in resultat.values()]))

        self.cnx.commit()
        cursor.close()

    def existe(self, valeurs: Dict[str, vartypes.csc_var]) -> bool:
        """Checks if a record containing valeurs exists

        Params:
            valeurs: the name of the variables and their value, for instance:
                    "K": csc_float(7.4), "n": csc_uint32(14638), "E": csc_float(15.9)}

        Returns:
            bool: True if the record exists, False otherwise
        """

        cursor = self.cnx.cursor(dictionary=True)
        cursor.execute("""SELECT COUNT(*) AS C FROM {} WHERE {}""".format(self.nom_projet,
                                                                          " AND ".join(
                                                                              ["{} = {}".format(
                                                                                  var,
                                                                                  str(val)
                                                                              ) for var, val in
                                                                                  valeurs.items()]
                                                                          )
                                                                          )
                       )
        res = cursor.fetchone()["C"]
        cursor.close()
        return res != 0

    def densifier(self, seuil: float, variable: str, offset: int = 0):
        """Sets up the DB for densification, ie finding the records MAXIMIZING the value of the
        variable named variable.
        This function won't return anything, but should be used when changing densification level.

        Params:
            seuil: the ratio of records that should be kept, ie seuil = 1., each record will
                    be selected
            variable: the name of the variable that should be used to find the best records
            offset: the offset used when selecting best candidates. Defaults to 0.
        """

        if not 0 < seuil <= 1:
            raise ValueError

        if variable not in self.schema:
            raise KeyError

        self.densifie = True

        # Keeping tracks of the parameters provided, we could need them
        self.seuil_densification = seuil
        self.offset_cour_densification = offset
        self.variable_densification = variable

        # First off, finding the number of records to compute the number
        # of records we're going to extract
        cursor = self.cnx.cursor(dictionary=True)
        cursor.execute(
            """SELECT COUNT(*) AS C FROM {} WHERE niv_densification={}""".format(
                self.nom_projet, self.niveau_densification))
        count = int(cursor.fetchone()["C"])
        cursor.close()

        logging.info(
            "Densification procedure on {} initialized. Current densifcation level is {}; "
            "this level has generated {} records".format(
                self.variable_densification,
                self.niveau_densification,
                count))

        # Computing the number of records we're keeping
        if self.niveau_densification == 1:
            limite = int(math.ceil(seuil * count))
        else:

            # We know that last time we drew limite_select configurations,
            # therefore each configuration would have had count/limite_select iterations.
            # Using a max to avoid division by zero errors
            limite = int(math.ceil(seuil * count / max(self.limite_select, 1)))

        if limite == 0 and not self.a_afficher_erreur_plus_echantillon:
            logging.warning(
                "No record found. "
                "Likely cause: records for this step have all been previously computed. "
                "Fix: adjust the numerical paramters for the densification. "
                "The issue we keep happening for the other densifications but this warning will "
                "only show up once."
            )
            self.a_afficher_erreur_plus_echantillon = True

        self.limite_select = limite

        logging.info("\tFor this densification step, {} schemes will be drawn".format(limite))

        self.niveau_densification += 1

    def schema_suivant(self,
                       schema_entree: Dict[str,
                                           Type[vartypes.csc_var]]) -> Dict[str,
                                                                            Tuple[Number,
                                                                                  Number,
                                                                                  Number]]:
        """Does most of the densification work.
        This consists in finding the best/most promising values
        for the parameters sent to the client and "zooming" on them
        and increasing the resolution (ie the step size between
        each sample point) near these points.

        Params:
            schema_entree: a scheme with the same shape as the scheme used to
                        initialize the database controller, but it should only
                        cointain the so-called outgoing variables that will be
                        sent to the slave servers, as these are the ones the
                        master have full control over

        Returns:
            dict: a dictionnary which keys are the keys of schema_entree and the values
                being 3-value tuples (<center value>, <immediately inferior neighbor>,
                <immediately superior neighbor>). The center value is the value that was
                previously computed by the client and determined to be "promising". Each
                of the neighbors coordinates (say there are N of them) are computed by
                iteratively setting the other coordinates (N-1 variables) to their respective
                value in the center vector, and then looking up the closet neighbors for the
                remaining "free" coordinate amongst the records of the DB having the other,
                N-1 variables set to their value.
                Some neighbors might be missing, for instance if the selected record is the one
                having the maximum values for the coordinates (is that case, their is no upper
                neighbor), then they are replaced by <center value>.
                If there are no new promising configurations to fetch (because the maximum number
                of candidates as computed in densifier() has been reached), the function returns
                None; in that case, one should call densifier() again.
        """

        if not self.densifie:
            return None

        cursor = self.cnx.cursor(dictionary=True)

        # On commence par extraire l'enregistrement avec les coordonnées bonnes
        cursor.execute(
            """SELECT *
            FROM {}
            WHERE niv_densification = {}-1
            ORDER BY {}
            DESC LIMIT 1
            OFFSET {}""".format(
                self.nom_projet,
                self.niveau_densification,
                self.variable_densification,
                self.offset_cour_densification))

        sch = cursor.fetchone()
        if sch is None:
            self.densifie = False
            return None

        self.offset_cour_densification += 1

        cursor.close()

        cursor = self.cnx.cursor()
        sch_vrai = {}

        # Recasting (CRITICAL for floats, because of the precision:
        # MySQL only displays the significant part of floats but expects a "long"
        # value for them, that we get by recasting)
        for n in schema_entree:
            sch_vrai[n] = schema_entree[n](sch[n])

        # on reprend le niveau de densification précédent
        # starting from the previous densification scheme
        sch_vrai["niv_densification"] = vartypes.csc_int32(self.niveau_densification - 1)

        # Then we find the closest neighbors for each coordinate
        xs = {xn: "{} = {}".format(xn, xv) for xn, xv in sch_vrai.items()}

        bornes = {}

        for n, v in sch_vrai.items():
            # We don't take the densification variable into account but it's what we're
            # trying to maximize
            if n != self.variable_densification and n != "niv_densification":
                val_python = sch[n]
                s = " AND ".join(
                    filter(
                        None, [
                            xs[xn] if xn != n and xn != self.variable_densification
                            else None
                            for xn in sch_vrai
                        ]
                    )
                )

                # cf https://ask.sqlservercentral.com/questions/103011/retrieve-closest-upper-and-lower-values.html # noqa
                # fetch the closest neighbors

                cursor.execute("""SELECT
                                        CASE SIGN({}-{})
                                            WHEN 1 THEN MIN({})
                                            ELSE        MAX({})
                                        END
                                AS  {}
                                FROM {} AS xV
                                WHERE {}
                                GROUP BY SIGN({}-{})
                                HAVING SIGN({}-{}) != 0
                                """.format(n, v, n, n, n, self.nom_projet,
                                           s, n, v, n, v))

                res = cursor.fetchall()

                # Issue: the connector returns the data as a tuple
                r = []
                for x in res:
                    if isinstance(x, tuple):
                        r.append(*x)
                    else:
                        r.append(x)
                res = sorted(r)

                if len(res) == 2:
                    bornes[n] = tuple([val_python, *res])
                elif len(res) == 1:
                    if res[0] < val_python:
                        bornes[n] = (val_python, res[0], val_python)
                    else:
                        bornes[n] = (val_python, val_python, res[0])
                elif len(res) == 0:
                    bornes[n] = (val_python, val_python, val_python)
                else:
                    raise BDDExceptionResultatsIngerable

        if self.offset_cour_densification >= self.limite_select:
            self.densifie = False

        # offset_cour_densification-1 because we just incremented it
        logging.info(
            "\tNew scheme drawn: {}, offset {}".format(
                bornes, self.offset_cour_densification - 1))

        return bornes

    def densification_en_cours(self) -> bool:
        """Checks whether a densification procedure is running

        Returns:
            True if a densification procedure is running; False if not
        """

        return self.densifie
